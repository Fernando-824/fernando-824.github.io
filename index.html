<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Portfolio</title>
    <link rel="stylesheet" href="style.css" />
</head>
<body>
    <header>
        <h1>Fernando S√°nchez Moya ‚Äî Portfolio</h1>
        <p class="subtitle">Estudiante de Ingenier√≠a de Computadores y Dise√±o y Desarrollo de Videojuegos (URJC)</p>
    </header>

    <main>
        <section class="intro">
            <h2>¬°Hola! üëã</h2>
            <p>
                Soy <strong>Fernando</strong>, estudiante del doble grado en Ingenier√≠a de Computadores y
                Dise√±o y Desarrollo de Videojuegos en la URJC.
                Este es mi portfolio, donde compartir√© mis proyectos de programaci√≥n y
                desarrollo de videojuegos.
            </p>
        </section>

        <section class="proyectos">
            <h2>Proyectos</h2>



            <div class="acordeon acordeon-gris-oscuro">
                <button class="acordeon-btn">Optimizaci√≥n del Renderizado de una Imagen con HPC (2025)<span class="icono">+</span></button>
                <div class="acordeon-contenido">
                    <div class="acordeon-flex-column">
                        <!-- Descripci√≥n -->
                        <div class="acordeon-texto">
                            <p>
                                Proyecto centrado en la <strong>aceleraci√≥n del renderizado de una imagen</strong> mediante diferentes modelos de paralelizaci√≥n:
                                <strong>OpenMP</strong> (paralelismo por hilos), <strong>OpenMPI</strong> (paralelismo distribuido entre nodos)
                                y <strong>CUDA</strong> (procesamiento masivo en GPU).
                            </p>

                            <p>
                                El objetivo fue comparar el rendimiento de cada enfoque, evaluando el tiempo de ejecuci√≥n y el aprovechamiento de recursos
                                al aplicar un algoritmo de trazado de rayos sobre una imagen de alta resoluci√≥n (1200x800).
                            </p>

                            <p>
                                A partir de una versi√≥n base secuencial del renderizado, se adapt√≥ el c√≥digo a cada tecnolog√≠a.
                                Para OpenMP, se utiliz√≥ la paralelizaci√≥n por bloques de p√≠xeles;
                                para OpenMPI, se distribuyeron las regiones de la imagen entre distintos nodos de c√°lculo;
                                y en CUDA, se asign√≥ cada p√≠xel a un hilo de ejecuci√≥n en la GPU.
                            </p>

                            <p>
                                CUDA ofreci√≥ la mejor mejora de rendimiento, logrando una aceleraci√≥n de aproximadamente el 90% frente a la versi√≥n secuencial.
                                OpenMP y OpenMPI tambi√©n presentaron un incremento notable al paralelizar en CPU, del 81% y el 68% respectivamente.
                            </p>
                        </div>

                        <!-- Imagen comparativa (gr√°fica o tabla) -->
                        <div class="acordeon-imagen">
                            <img src="images/OptimizacionGraph.png" alt="Comparativa de tiempos de ejecuci√≥n entre OpenMP, MPI y CUDA" />
                            <img src="images/OptimizacionGraph%.png" alt="Porcentaje de mejora en los tiempos entre OpenMP, MPI y CUDA" />
                        </div>
                    </div>
                </div>
            </div>



            <div class="acordeon acordeon-morado">
                <button class="acordeon-btn">Implementaci√≥n de K-Means con HPC (2025)<span class="icono">+</span></button>
                <div class="acordeon-contenido">
                    <div class="acordeon-flex-column">
                        <div class="acordeon-texto">
                            <p>
                                Implementaci√≥n del algoritmo K-Means en C++ con paralelizaci√≥n combinando OpenMPI y OpenMP.
                                Se distribuy√≥ la carga de c√°lculo entre varios nodos e hilos,
                                manteniendo la consistencia de datos y evitando condiciones de carrera.
                                De esta manera, se optimiz√≥ el tiempo de ejecuci√≥n y
                                se aprovech√≥ al m√°ximo la memoria distribuida y compartida.
                            </p>

                            <p>
                                El mejor rendimiento se obtuvo con dos procesadores activos,
                                ya que a partir de tres la comunicaci√≥n entre nodos (con MPI)
                                comenzaba a introducir m√°s sobrecarga que el propio c√°lculo del algoritmo.
                            </p>
                        </div>

                        <div class="acordeon-imagen">
                            <img src="images/KMeansGraph.png" alt="Comparativa de tiempos con distintos procesadores">
                        </div>
                    </div>
                </div>
            </div>



            <div class="acordeon acordeon-naranja">
                <button class="acordeon-btn">Project Paintball (2025)<span class="icono">+</span></button>
                <div class="acordeon-contenido">
                    <div class="acordeon-flex">
                        <!-- Columna izquierda: texto y enlaces -->
                        <div class="acordeon-texto">
                            <p>
                                Project Paintball es un FPS multijugador que permite partidas de 1v1, 2v2 y 3v3.
                                Los jugadores pueden elegir entre distintos agentes u operativos, cada uno con armas y habilidades √∫nicas.
                                El juego combina escenarios ficticios visualmente atractivos con gemelos digitales de escenarios reales de empresas de paintball,
                                con la idea de que los jugadores quieran probar tanto el juego como los escenarios f√≠sicos.
                            </p>

                            <p>
                                Me encargu√© del level design y del desarrollo de los modelos de los escenarios,
                                program√© las habilidades de los personajes y ayud√© con otros elementos del gameplay,
                                enfoc√°ndome sobre todo en <strong>programaci√≥n</strong> y <strong>dise√±o de niveles</strong>.
                            </p>

                            <p>
                                <strong>Enlaces:</strong><br>
                                <a href="https://psycoffin-studios.github.io/" target="_blank">Portfolio del equipo</a><br>
                                <a href="https://p11-a03.itch.io/project-paintball-by-psycoffin" target="_blank">P√°gina en Itch.io</a>
                            </p>
                        </div>

                        <!-- Columna derecha: imagen -->
                        <div class="acordeon-imagen">
                            <img src="images/ProjectPaintball.png" alt="Project Paintball" />
                        </div>
                    </div>
                </div>
            </div>



            <div class="acordeon acordeon-gris-oscuro">
                <button class="acordeon-btn">Demo 2D con Unity (2023)<span class="icono">+</span></button>
                <div class="acordeon-contenido">
                    <div class="acordeon-flex-column">
                        <div class="acordeon-texto">
                            <p>
                                Desarrollo completo de una peque√±a demo 2D desde cero, encarg√°ndome tanto del dise√±o como de la programaci√≥n.
                                El objetivo del proyecto era crear una experiencia de sigilo en la que el jugador debe avanzar por un escenario en dos dimensiones
                                eliminando enemigos sin ser detectado.
                            </p>

                            <p>
                                <strong>Dise√±o y animaciones:</strong> Cre√© todos los <em>sprites</em> del personaje jugable y de los enemigos, incluyendo animaciones diferenciadas de movimiento,
                                ataque y muerte. El personaje principal tambi√©n cuenta con animaciones adicionales de salto y escalada, ajustadas mediante el sistema <em>Animator</em> de Unity.
                            </p>

                            <p>
                                <strong>Programaci√≥n:</strong> Implement√© las mec√°nicas principales del juego: salto, detecci√≥n de colisiones y sistema de eliminaci√≥n.
                                Los enemigos cuentan detecci√≥n visual mediante una linterna frontal, si el enemigo detecta al jugador, lo elimina;
                                si el jugador se acerca por detr√°s, puede acabar con √©l.
                            </p>
                        </div>

                        <div class="acordeon-imagen-centro">
                            <img src="images/2D.gif" alt="Gameplay demo 2D">
                        </div>
                    </div>
                </div>
            </div>



            <div class="acordeon acordeon-verde">
                <button class="acordeon-btn">Escenario y Personaje 3D con Animaciones (2024)<span class="icono">+</span></button>
                <div class="acordeon-contenido">
                    <div class="acordeon-flex-column">
                        <!-- Descripci√≥n -->
                        <div class="acordeon-texto">
                            <p>
                                Proyecto centrado en el desarrollo de un <strong>escenario 3D animado</strong> y un <strong>personaje completo</strong>,
                                aplicando t√©cnicas de modelado, rigging y animaci√≥n en Autodesk 3ds Max.
                                Ambos trabajos fueron finalmente integrados en Unity para crear una peque√±a escena interactiva.
                            </p>

                            <p>
                                En el <strong>escenario</strong> se model√≥ una ciudad parcialmente destruida,
                                en la que se anim√≥ el derrumbamiento de un edificio y un comportamiento de manada para un grupo de drones que patrullaban el entorno.
                            </p>

                            <p>
                                En el <strong>personaje</strong>, se realiz√≥ el modelado desde cero, el rigging completo y las animaciones b√°sicas,
                                prepar√°ndolo para su uso dentro de un motor de juego.
                            </p>

                            <p>
                                Como parte final del trabajo, ambos elementos fueron <strong>integrados en Unity</strong>,
                                combinando el escenario y el personaje en una misma escena jugable para mostrar la coherencia visual y t√©cnica del conjunto.
                            </p>
                        </div>

                        <!-- GIFs horizontales -->
                        <div class="acordeon-imagenes">
                            <img src="images/3D_Escenario.gif" alt="Animaci√≥n del escenario 3D" />
                            <img src="images/3D_Personaje.gif" alt="Animaci√≥n Idle del personaje" />
                            <img src="images/3D_Final.gif" alt="Proyecto implementado en Unity" />
                        </div>
                    </div>
                </div>
            </div>



            <div class="acordeon acordeon-azul">
                <button class="acordeon-btn">Proyecto de Programaci√≥n Orientada a Objetos con C++ (2023)<span class="icono">+</span></button>
                <div class="acordeon-contenido">
                    <div class="acordeon-flex-column">
                        <!-- Columna izquierda: texto -->
                        <div class="acordeon-texto">
                            <p>
                                Este proyecto consisti√≥ en el desarrollo de un peque√±o juego de naves en C++ aplicando los principios de la <strong>Programaci√≥n Orientada a Objetos (POO)</strong>.
                                El jugador controla una nave que puede desplazarse lateralmente, disparar y esquivar enemigos,
                                mientras aparecen distintos tipos de oponentes con diferentes comportamientos.
                            </p>

                            <p>
                                Para su desarrollo se implement√≥ una arquitectura modular basada en clases:
                                <strong>Ship</strong> (nave del jugador y enemigos),
                                <strong>Laser</strong> (proyectiles),
                                <strong>Item</strong> (√≠tems de salud o energ√≠a),
                                y <strong>Bar</strong> (barras de salud y energ√≠a).
                                Estas clases hacen uso de <strong>herencia, encapsulaci√≥n y polimorfismo</strong>
                                para definir comportamientos independientes y reutilizables dentro del motor del juego.
                            </p>
                            <p>
                                Este proyecto fue una pr√°ctica clave para afianzar conceptos de POO en C++,
                                mostrando c√≥mo los principios de dise√±o pueden aplicarse para mantener un c√≥digo limpio, organizado y mantenible.
                            </p>
                        </div>

                        <!-- Im√°genes -->
                        <div class="acordeon-imagenes">
                            <img src="images/POOuml.png" alt="Diagrama UML del proyecto" />
                            <img src="images/POOgame.png" alt="Juego de naves en ejecuci√≥n" />
                            <img src="images/POOgame2.png" alt="Captura de gameplay del proyecto" />
                        </div>
                    </div>
                </div>
            </div>



            <div class="acordeon acordeon-arduino">
                <button class="acordeon-btn">Juego con Arduino (2024)<span class="icono">+</span></button>
                <div class="acordeon-contenido">
                    <div class="acordeon-flex-column">
                        <!-- Descripci√≥n -->
                        <div class="acordeon-texto">
                            <p>
                                Este proyecto consiste en el desarrollo de un juego de combate inspirado en Pok√©mon, utilizando hardware f√≠sico basado en <strong>Arduino</strong>.
                                El sistema permite enfrentar dos personajes mediante <strong>llaveros NFC</strong>, cada uno con un identificador √∫nico.
                                Al pasar los dos llaveros por el lector NFC, el Arduino detecta los IDs y genera autom√°ticamente la escena de combate en una pantalla t√°ctil.
                                Cada personaje se carga con sus atributos almacenados en una <strong>tarjeta microSD</strong> (puntos de salud, ataques y sprites personalizados)
                                optimizando el uso de memoria, ya que la capacidad interna del Arduino era muy limitada.
                            </p>
                            <p>
                                Me encargu√© del desarrollo del <strong>software</strong> del proyecto,
                                especialmente de la programaci√≥n para la lectura y escritura en la tarjeta microSD, con el objetivo de hacerlo modular y escalable.
                                De esta forma, se podr√≠an crear y a√±adir nuevos personajes f√°cilmente en el futuro sin modificar el c√≥digo base.
                                Adem√°s, implement√© el sistema de combate, encarg√°ndome de la <strong>l√≥gica</strong> del gameplay y de la interacci√≥n entre los personajes durante las batallas.
                            </p>
                        </div>

                        <!-- Im√°genes horizontales -->
                        <div class="acordeon-imagenes">
                            <img src="images/arduinoLector.png" alt="Arduino Lector de Tarjetas" />
                            <img src="images/arduinoCombate1.png" alt="Arduino Pantalla de Juego" />
                            <img src="images/arduinoCombate2.png" alt="Arduino Imagen de Versi√≥n Final" />
                        </div>
                    </div>
                </div>
            </div>
        </section>



        <section class="contacto">
            <h2>Contacto</h2>
            <ul>
                <li><a href="mailto:fernandosanchezmoya82@gmail.com">üìß Correo</a></li>
                <li><a href="https://github.com/Fernando-824" target="_blank">üíª GitHub</a></li>
                <li><a href="https://www.linkedin.com/in/fernando-s√°nchez-moya-559a291a0/" target="_blank">üîó LinkedIn</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <p>¬© 2025 Fernando ‚Äî Portfolio personal</p>
    </footer>

    <script>
        const botones = document.querySelectorAll(".acordeon-btn");
        botones.forEach(boton => {
            boton.addEventListener("click", () => {
                const contenido = boton.nextElementSibling;
                const icono = boton.querySelector(".icono");

                if (contenido.classList.contains("activo")) {
                    contenido.classList.remove("activo");
                    icono.textContent = "+";
                } else {
                    document.querySelectorAll(".acordeon-contenido").forEach(c => c.classList.remove("activo"));
                    document.querySelectorAll(".icono").forEach(i => i.textContent = "+");

                    contenido.classList.add("activo");
                    icono.textContent = "‚àí";
                }
            });
        });
    </script>

</body>
</html>
